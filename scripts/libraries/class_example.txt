
The new inheritiance model, I think, is best explained with code.

Let's define an Animal class:

// Animal base class
var Animal = Class.extend(function(base) {
    return {
        // The `init` method serves as the constructor.
        init: function() {

            // Insert private functions here
            function private1(){}
            function private2(){}

            // Insert priviledged functions here
            this.privileged1 = function(){}
            this.privileged2 = function(){}
        },
        method1: function(){}
    }
});
Class.extend expects a function that returns an object literal. That object 
literal is used to construct the prototype. The init method in the object
literal acts as the constructor, which is invoked when an instance is 
created. That is:

var animal = new Animal(); // Create a new Animal instance
init is invoked automatically.

Inheriting

Now, suppose I want to create a Dog class. Since a dog is essentially an animal, 
then it should inherit from Animal. Note that every class definition has access 
to the parent's prototype via the base argument (or whatever you named it, since 
the consumer controls this).

// Extend the Animal class.
var Dog = Animal.extend(function(base) {
    return {
        init: function(prop) {
            // Call the base init.
            base.init.call(this);
        },
        // Override base class `method1`
        method1: function(){},
        scare: function(){
            console.log('Dog::I scare you');
        }
    }
});
Create an instance of Dog:

var husky = new Dog();
husky.scare(); // "Dog::I scare you'"
Decorating

The ability to decorate instances is quite powerful. As an example:

var Domesticated = function(obj, base) {
    // Override the instance' scare method
    obj.scare = function(){
        console.log('Domesticated::sorry, we dont scare');
    }

    // Add a method
    obj.kneel = function(){}

    // Bind some custom events
    $(obj).on('barking', function() {});
};
From the above, you can see that a decorator is merely a function that expects 
an instance and the base prototype, both of which are provided by the Class 
library. Within this function, you can override, augment, bind... - that is, 
decorate, the instance as you please.

So, back to our husky example. To decorate the instance, use decorate:

huksy.decorate(Domesticated);
husky.scare(); // "Domesticated::sorry, we don't scare"
And there you have it.

